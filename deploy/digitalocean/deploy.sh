#!/usr/bin/env bash
# ──────────────────────────────────────────────────────────────────────────────
# ListingAI — Post-Terraform Deployment Script
# Run AFTER `terraform apply` to configure and start the application stack.
#
# Usage:
#   ./deploy.sh                    # Full deploy (generate .env, push, start)
#   ./deploy.sh --update           # Code update only (git pull, rebuild, restart)
#   ./deploy.sh --env-only         # Regenerate .env from Terraform outputs
#   ./deploy.sh --tls              # Run TLS certificate provisioning
# ──────────────────────────────────────────────────────────────────────────────
set -euo pipefail

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
REMOTE_DIR="/opt/listingai"
COMPOSE_CMD="docker compose -f docker/docker-compose.yml -f deploy/digitalocean/docker-compose.do.yml"

# ── Colors ───────────────────────────────────────────────────────────────────
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
CYAN='\033[0;36m'
NC='\033[0m'

log()  { echo -e "${GREEN}[deploy]${NC} $*"; }
warn() { echo -e "${YELLOW}[warn]${NC} $*"; }
err()  { echo -e "${RED}[error]${NC} $*" >&2; }

# ── Read Terraform outputs ───────────────────────────────────────────────────

read_tf_output() {
  terraform -chdir="$SCRIPT_DIR" output -raw "$1" 2>/dev/null
}

read_tf_output_json() {
  terraform -chdir="$SCRIPT_DIR" output -json "$1" 2>/dev/null
}

DROPLET_IP="$(read_tf_output droplet_ip)"
if [[ -z "$DROPLET_IP" ]]; then
  err "Cannot read Terraform outputs. Did you run 'terraform apply'?"
  exit 1
fi

SSH_CMD="ssh -o StrictHostKeyChecking=accept-new deploy@${DROPLET_IP}"
SCP_CMD="scp -o StrictHostKeyChecking=accept-new"

# ── Wait for cloud-init ─────────────────────────────────────────────────────

wait_for_cloud_init() {
  log "Waiting for cloud-init to complete on ${DROPLET_IP}..."
  local attempts=0
  local max_attempts=60  # 5 minutes at 5s intervals

  while ! $SSH_CMD "test -f /opt/listingai-data/.cloud-init-complete" 2>/dev/null; do
    attempts=$((attempts + 1))
    if [[ $attempts -ge $max_attempts ]]; then
      err "Timed out waiting for cloud-init (${max_attempts} attempts)"
      err "Check: ssh deploy@${DROPLET_IP} 'cat /var/log/cloud-init-output.log | tail -50'"
      exit 1
    fi
    echo -n "."
    sleep 5
  done
  echo ""
  log "Cloud-init complete."
}

# ── Generate .env from Terraform outputs ────────────────────────────────────

generate_env() {
  log "Generating .env from Terraform outputs..."

  local DB_URL="$(read_tf_output database_url)"
  local DB_URL_SYNC="$(read_tf_output database_url_sync)"
  local REDIS_URL="$(read_tf_output redis_url)"
  local CELERY_BROKER="$(read_tf_output celery_broker_url)"
  local SPACES_ENDPOINT="$(read_tf_output spaces_endpoint)"
  local SPACES_BUCKET="$(read_tf_output spaces_bucket_name)"
  local PG_PASS="$(read_tf_output postgres_password)"

  # Prompt for secrets that Terraform does not manage
  local APP_SECRET_KEY ANTHROPIC_KEY JWT_SECRET ENCRYPTION_KEY
  local STRIPE_SK STRIPE_PK STRIPE_WH SENDGRID_KEY SENTRY_DSN

  if [[ -f "$SCRIPT_DIR/.env.secrets" ]]; then
    log "Loading application secrets from .env.secrets"
    # shellcheck disable=SC1091
    source "$SCRIPT_DIR/.env.secrets"
  else
    warn "No .env.secrets file found. You will need to fill in secrets manually."
    warn "Create deploy/digitalocean/.env.secrets with:"
    warn "  APP_SECRET_KEY=... ANTHROPIC_API_KEY=... JWT_SECRET_KEY=..."
    warn "  ENCRYPTION_KEY=... STRIPE_SECRET_KEY=... STRIPE_PUBLISHABLE_KEY=..."
    warn "  STRIPE_WEBHOOK_SECRET=... SENDGRID_API_KEY=... SENTRY_DSN=..."

    APP_SECRET_KEY="${APP_SECRET_KEY:-REPLACE_ME}"
    ANTHROPIC_API_KEY="${ANTHROPIC_API_KEY:-REPLACE_ME}"
    JWT_SECRET_KEY="${JWT_SECRET_KEY:-REPLACE_ME}"
    ENCRYPTION_KEY="${ENCRYPTION_KEY:-REPLACE_ME}"
    STRIPE_SECRET_KEY="${STRIPE_SECRET_KEY:-REPLACE_ME}"
    STRIPE_PUBLISHABLE_KEY="${STRIPE_PUBLISHABLE_KEY:-REPLACE_ME}"
    STRIPE_WEBHOOK_SECRET="${STRIPE_WEBHOOK_SECRET:-REPLACE_ME}"
    STRIPE_PRICE_ID_STARTER="${STRIPE_PRICE_ID_STARTER:-REPLACE_ME}"
    STRIPE_PRICE_ID_PROFESSIONAL="${STRIPE_PRICE_ID_PROFESSIONAL:-REPLACE_ME}"
    STRIPE_PRICE_ID_ENTERPRISE="${STRIPE_PRICE_ID_ENTERPRISE:-REPLACE_ME}"
    SENDGRID_API_KEY="${SENDGRID_API_KEY:-REPLACE_ME}"
    SENTRY_DSN="${SENTRY_DSN:-REPLACE_ME}"
  fi

  local DOMAIN
  DOMAIN="$(terraform -chdir="$SCRIPT_DIR" output -raw app_url 2>/dev/null | sed 's|https://||')"
  DOMAIN="${DOMAIN:-app.listingai.com}"

  cat > "$SCRIPT_DIR/.env.generated" << ENVEOF
# ──────────────────────────────────────────────────────────────────────────────
# ListingAI — Production Environment (DigitalOcean)
# Generated by deploy.sh at $(date -u +"%Y-%m-%dT%H:%M:%SZ")
# DO NOT COMMIT THIS FILE
# ──────────────────────────────────────────────────────────────────────────────

# Application
APP_ENV=production
APP_DEBUG=false
APP_SECRET_KEY=${APP_SECRET_KEY}
APP_URL=https://${DOMAIN}
FRONTEND_URL=https://${DOMAIN}
ALLOWED_HOSTS=${DOMAIN}

# Sentry
SENTRY_DSN=${SENTRY_DSN}
SENTRY_TRACES_SAMPLE_RATE=0.1

# PostgreSQL (DigitalOcean Managed — private network, TLS required)
DATABASE_URL=${DB_URL}
DATABASE_URL_SYNC=${DB_URL_SYNC}
POSTGRES_USER=listingai
POSTGRES_PASSWORD=${PG_PASS}
POSTGRES_DB=listingai

# Redis (DigitalOcean Managed — private network, TLS required)
REDIS_URL=${REDIS_URL}
CELERY_BROKER_URL=${CELERY_BROKER}

# Anthropic (Claude API)
ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}

# JWT
JWT_SECRET_KEY=${JWT_SECRET_KEY}
JWT_ALGORITHM=HS256
JWT_ACCESS_TOKEN_EXPIRE_MINUTES=30
JWT_REFRESH_TOKEN_EXPIRE_DAYS=7

# Encryption (Fernet key for MLS credentials)
ENCRYPTION_KEY=${ENCRYPTION_KEY}

# Stripe
STRIPE_SECRET_KEY=${STRIPE_SECRET_KEY}
STRIPE_PUBLISHABLE_KEY=${STRIPE_PUBLISHABLE_KEY}
STRIPE_WEBHOOK_SECRET=${STRIPE_WEBHOOK_SECRET}
STRIPE_PRICE_ID_STARTER=${STRIPE_PRICE_ID_STARTER}
STRIPE_PRICE_ID_PROFESSIONAL=${STRIPE_PRICE_ID_PROFESSIONAL}
STRIPE_PRICE_ID_ENTERPRISE=${STRIPE_PRICE_ID_ENTERPRISE}

# S3 / DigitalOcean Spaces
S3_ENDPOINT_URL=${SPACES_ENDPOINT}
S3_ACCESS_KEY=$(terraform -chdir="$SCRIPT_DIR" output -raw spaces_access_key 2>/dev/null || echo "FROM_TFVARS")
S3_SECRET_KEY=$(terraform -chdir="$SCRIPT_DIR" output -raw spaces_secret_key 2>/dev/null || echo "FROM_TFVARS")
S3_BUCKET_NAME=${SPACES_BUCKET}
S3_REGION=$(terraform -chdir="$SCRIPT_DIR" output -raw spaces_region 2>/dev/null || echo "nyc3")

# MLS
MLS_DEFAULT_BASE_URL=https://api-trestle.corelogic.com
MLS_SYNC_INTERVAL_MINUTES=30

# SendGrid
SENDGRID_API_KEY=${SENDGRID_API_KEY}

# Monitoring
GRAFANA_ADMIN_USER=admin
GRAFANA_ADMIN_PASSWORD=$(openssl rand -base64 24 2>/dev/null || echo "REPLACE_ME")

# CORS
CORS_ORIGINS=https://${DOMAIN}

# Frontend
NEXT_PUBLIC_API_URL=https://api.$(echo "$DOMAIN" | sed 's/^app\.//')
ENVEOF

  log "Generated .env.generated"
}

# ── Push .env to server ─────────────────────────────────────────────────────

push_env() {
  log "Copying .env to ${DROPLET_IP}:${REMOTE_DIR}/.env"
  $SCP_CMD "$SCRIPT_DIR/.env.generated" "deploy@${DROPLET_IP}:${REMOTE_DIR}/.env"
  $SSH_CMD "chmod 600 ${REMOTE_DIR}/.env"
  log ".env deployed."
}

# ── Build and start the stack ────────────────────────────────────────────────

start_stack() {
  log "Building and starting the Docker Compose stack..."
  $SSH_CMD << REMOTEOF
    set -euo pipefail
    cd ${REMOTE_DIR}

    # Build images
    ${COMPOSE_CMD} --env-file .env build

    # Start the stack
    ${COMPOSE_CMD} --env-file .env up -d

    # Wait for backend to be healthy
    echo "Waiting for backend health check..."
    for i in \$(seq 1 30); do
      if docker compose -f docker/docker-compose.yml -f deploy/digitalocean/docker-compose.do.yml exec -T backend python -c "import urllib.request; urllib.request.urlopen('http://127.0.0.1:8000/health/live')" 2>/dev/null; then
        echo "Backend is healthy."
        break
      fi
      echo -n "."
      sleep 5
    done
    echo ""
REMOTEOF
  log "Stack is running."
}

# ── Run database migrations ──────────────────────────────────────────────────

run_migrations() {
  log "Running Alembic migrations..."
  $SSH_CMD "cd ${REMOTE_DIR} && ${COMPOSE_CMD} exec -T backend alembic upgrade head"
  log "Migrations complete."
}

# ── TLS certificate provisioning ────────────────────────────────────────────

setup_tls() {
  local DOMAIN
  DOMAIN="$(terraform -chdir="$SCRIPT_DIR" output -raw app_url 2>/dev/null | sed 's|https://||')"
  local API_DOMAIN
  API_DOMAIN="$(terraform -chdir="$SCRIPT_DIR" output -raw api_url 2>/dev/null | sed 's|https://||')"
  local EMAIL
  EMAIL="$(terraform -chdir="$SCRIPT_DIR" output -raw alert_email 2>/dev/null || echo 'admin@listingai.com')"

  log "Provisioning TLS certificates for ${DOMAIN} and ${API_DOMAIN}..."
  $SSH_CMD << TLSEOF
    set -euo pipefail
    cd ${REMOTE_DIR}

    # Request certificate via certbot (webroot mode — nginx must be running on :80)
    ${COMPOSE_CMD} exec -T certbot certbot certonly \
      --webroot -w /var/www/certbot \
      -d ${DOMAIN} -d ${API_DOMAIN} \
      --agree-tos --email ${EMAIL} --non-interactive

    # Reload nginx to pick up the new cert
    ${COMPOSE_CMD} exec -T nginx nginx -s reload

    echo "TLS certificates provisioned successfully."
TLSEOF
  log "TLS setup complete."
}

# ── Print status ─────────────────────────────────────────────────────────────

print_status() {
  log "Checking deployment status..."
  $SSH_CMD << STATUSEOF
    set -euo pipefail
    cd ${REMOTE_DIR}

    echo ""
    echo "=============================="
    echo "  Container Status"
    echo "=============================="
    ${COMPOSE_CMD} ps

    echo ""
    echo "=============================="
    echo "  Health Checks"
    echo "=============================="
    curl -sf http://127.0.0.1:8000/health/live  2>/dev/null && echo "Backend /health/live:  OK" || echo "Backend /health/live:  FAIL"
    curl -sf http://127.0.0.1:8000/health/ready 2>/dev/null && echo "Backend /health/ready: OK" || echo "Backend /health/ready: FAIL"
    curl -sf http://127.0.0.1:3000/             2>/dev/null && echo "Frontend:              OK" || echo "Frontend:              FAIL"

    echo ""
    echo "=============================="
    echo "  Disk & Memory"
    echo "=============================="
    df -h / | tail -1
    free -h | head -2
    echo ""
STATUSEOF

  echo ""
  log "Deployment summary:"
  echo -e "  ${CYAN}Droplet:${NC}   ${DROPLET_IP}"
  echo -e "  ${CYAN}SSH:${NC}       ssh deploy@${DROPLET_IP}"
  echo -e "  ${CYAN}App:${NC}       $(read_tf_output app_url)"
  echo -e "  ${CYAN}API:${NC}       $(read_tf_output api_url)"
  echo ""
}

# ── Code update (git pull + rebuild) ────────────────────────────────────────

update_code() {
  log "Updating code on ${DROPLET_IP}..."
  $SSH_CMD << UPDATEEOF
    set -euo pipefail
    cd ${REMOTE_DIR}

    git pull origin main

    # Rebuild only application images
    ${COMPOSE_CMD} --env-file .env build backend worker frontend

    # Run migrations before restart
    ${COMPOSE_CMD} exec -T backend alembic upgrade head

    # Rolling restart of application services
    ${COMPOSE_CMD} --env-file .env up -d --no-deps backend worker beat frontend

    # Reload nginx config if it changed
    ${COMPOSE_CMD} exec -T nginx nginx -s reload 2>/dev/null || true

    echo "Update complete."
UPDATEEOF
  log "Code update deployed."
}

# ── Main ─────────────────────────────────────────────────────────────────────

main() {
  local mode="${1:-full}"

  case "$mode" in
    --update)
      update_code
      print_status
      ;;
    --env-only)
      generate_env
      push_env
      ;;
    --tls)
      setup_tls
      ;;
    --status)
      print_status
      ;;
    full|*)
      log "Starting full deployment to DigitalOcean..."
      echo ""

      wait_for_cloud_init
      generate_env
      push_env
      start_stack
      run_migrations
      print_status

      echo ""
      warn "TLS certificates not yet provisioned."
      warn "Once DNS is pointing to ${DROPLET_IP}, run:"
      warn "  ./deploy.sh --tls"
      echo ""
      ;;
  esac
}

main "$@"
